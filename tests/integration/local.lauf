module @local;

const @test_failure = "test failure", 0;

function @assert_eq(2 => 0) {
    call_builtin @scmp;
    global_addr @test_failure; panic_if cmp_ne;
    return;
}

function @test_value(0 => 0) {
    local %x : @Value;

    int 42; store_value %x;
    int 11; store_value %x;

    load_value %x;
    int 11; call @assert_eq;

    return;
}

function @test_value_field(0 => 0) {
    local %x : @Value;

    int 42; local_addr %x; store_field @Value.0;
    int 11; local_addr %x; store_field @Value.0;

    local_addr %x; load_field @Value.0;
    int 11; call @assert_eq;

    return;
}

function @test_layout(0 => 0) {
    # layout of Value type hardcoded.
    local %x : (8, 8);

    int 42; store_value %x;
    int 11; store_value %x;

    load_value %x;
    int 11; call @assert_eq;

    return;
}

function @test_array(0 => 0) {
    local %x : @Value[2];

    int 42; int 0; local_addr %x; array_element_addr @Value; store_field @Value.0;
    int 11; int 1; local_addr %x; array_element_addr @Value; store_field @Value.0;

    int 0; local_addr %x; array_element_addr @Value; load_field @Value.0;
    int 42; call @assert_eq;

    int 1; local_addr %x; array_element_addr @Value; load_field @Value.0;
    int 11; call @assert_eq;

    return;
}
function @test_nested_array(0 => 0) {
    local %x : @Value[1][2];

    int 42; int 0; {int 0; local_addr %x; array_element_addr @Value[1];} array_element_addr @Value; store_field @Value.0;
    int 11; int 1; {int 0; local_addr %x; array_element_addr @Value[1];} array_element_addr @Value; store_field @Value.0;

    int 0; {int 0; local_addr %x; array_element_addr @Value[1];} array_element_addr @Value; load_field @Value.0;
    int 42; call @assert_eq;

    int 0; {int 1; local_addr %x; array_element_addr @Value;} array_element_addr @Value; load_field @Value.0;
    int 11; call @assert_eq;

    return;
}

function @test_array_value(0 => 0) {
    local %x : @Value[2];

    int 42; int 0; store_array_value %x;
    int 11; int 1; store_array_value %x;

    int 0; load_array_value %x;
    int 42; call @assert_eq;

    int 1; load_array_value %x;
    int 11; call @assert_eq;

    return;
}

function @set_ptr(1 => 0) {
    int 42; roll 1; store_field @Value.0;
    return;
}
function @test_pass_local_to_function(0 => 0) {
    local %x : @Value;
    local_addr %x; call @set_ptr;

    load_value %x; int 42; call @assert_eq;
    return;
}

function @test_invalid_array_index_panic(0 => 0) {
    local %x : @Value[2];

    int 42; int 2; local_addr %x; array_element_addr @Value; store_field @Value.0;
    return;
}
function @test_invalid_array_value_index_panic(0 => 0) {
    local %x : @Value[2];

    int 42; int 2; store_array_value %x;
    return;
}
function @test_local_arithmetic_panic(0 => 0) {
    local %x : @Value;

    int 42; local_addr %x; int 11; call_builtin @sadd; store_field @Value.0;
    return;
}
function @test_local_arithmetic_next_panic(0 => 0) {
    local %x : @Value;
    local %y : @Value;
    local %z : @Value;

    # The offset advances y to the next local.
    int 42; local_addr %y; int 34359738368; call_builtin @sadd; store_field @Value.0;
    return;
}
function @test_local_arithmetic_alignment_panic(0 => 0) {
    local %x : @Value[2];

    # The offset advances x 4 bytes.
    int 42; local_addr %x; int 17179869184; call_builtin @sadd; store_field @Value.0;
    return;
}

function @dangling_addr(0 => 1) {
    local %x : @Value;
    local_addr %x; return;
}
function @test_dangling_addr_panic(0 => 0) {
    int 42; call @dangling_addr; store_field @Value.0;
    return;
}

function @test_dangling_addr_reuse_panic(0 => 0) {
    call @dangling_addr; call @set_ptr;
    return;
}

