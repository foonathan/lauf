module @fib;

const @test_failure = "test failure", 0;

function @fib_recursive(1 => 1) {
    local %arg : @Value;

    store_value %arg;

    load_value %arg; int 1; call_builtin @scmp;
    jump_if cmp_gt %recurse;

    load_value %arg;
    return;

label %recurse:
    load_value %arg; int 1; call_builtin @ssub;
    call @fib_recursive;

    load_value %arg; int 2; call_builtin @ssub;
    call @fib_recursive;

    call_builtin @sadd;
    return;
}

function @fib_tail_call(3 => 1) { # n a b => F_n
    local %a : @Value;
    local %b : @Value;

    store_value %b;
    store_value %a;

    pick 0; int 0; call_builtin @scmp;
    jump_if cmp_eq %is_zero;

    pick 0; int 1; call_builtin @scmp;
    jump_if cmp_eq %is_one;

    int 1; call_builtin @ssub;
    load_value %b;
    pick 0; load_value %a; call_builtin @sadd;
    call @fib_tail_call;
    return;

label %is_zero(1):
    drop 1;
    load_value %a; return;
label %is_one(1):
    drop 1;
    load_value %b; return;
}

function @fib_iter(1 => 1) {
    local %a : @Value;
    local %b : @Value;

    int 0; store_value %a;
    int 1; store_value %b;

    pick 0; int 0; call_builtin @scmp;
    jump_if cmp_eq %exit;

label %loop(1):
    load_value %b; # => b

    pick 0;             # => b b
    load_value %a;      # => b b a
    call_builtin @sadd; # => b (b+a)

    store_value %b;
    store_value %a;

    int 1; call_builtin @ssub;
    pick 0; int 0; call_builtin @scmp;
    jump_if cmp_ne %loop;

label %exit(1):
    drop 1;
    load_value %a;
    return;
}

function @test_fib(0 => 0) {
    int 10; call @fib_recursive;
    int 55; call_builtin @scmp;
    ptr @test_failure; panic_if cmp_ne;

    int 10; int 0; int 1; call @fib_tail_call;
    int 55; call_builtin @scmp;
    ptr @test_failure; panic_if cmp_ne;

    int 10; call @fib_iter;
    int 55; call_builtin @scmp;
    ptr @test_failure; panic_if cmp_ne;

    return;
}

